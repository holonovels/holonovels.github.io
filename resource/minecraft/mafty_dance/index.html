<!DOCTYPE html>
<html lang="ja">
	<head>
		<meta charset="utf-8" />
		<script src="config.js"></script>
		<title>MMD 3Dモデルを表示する MMDAnimationHelperによるアニメーションやポーズ</title>
	</head>
	<body>
		<!-- MMDが描画されるHTML要素 -->
		<div id="webgl" style="width: 100%;"></div>
		<br />
		<form name="form1" style="text-align: center; width: 100%;">
			<!-- ステレオ表示へ切り替えるためのボタン -->
			<button type="button" name="button1">ステレオ表示</button><br />
			<br />
			<!-- PNG画像保存ボタン -->
			<button type="button" name="button2">PNG画像保存</button>
			<!-- WebM動画保存ボタン -->
			<button type="button" name="button3">WebM動画保存</button>
		</form>
		<br />
		<form name="form2" style="text-align: center; width: 100%;">
			<!-- モーションの開始/一時停止ボタン -->
			<button type="button">M01</button>
			<button type="button">M02</button>
			<button type="button">M03</button>
			<button type="button">M04</button>
			<button type="button">M05</button>
			<button type="button">M06</button>
			<button type="button">M07</button>
			<button type="button">M08</button><br />
			<button type="button">M09</button>
			<button type="button">M10</button>
			<button type="button">M11</button>
			<button type="button">M12</button>
			<button type="button">M13</button>
			<button type="button">M14</button>
			<button type="button">M15</button>
			<button type="button">M16</button><br />
		</form>
		<br />
		<form name="form3" style="text-align: center; width: 100%;">
			<!-- ポーズの開始/一時停止ボタン -->
			<button type="button">P01</button>
			<button type="button">P02</button>
			<button type="button">P03</button>
			<button type="button">P04</button>
			<button type="button">P05</button>
			<button type="button">P06</button>
			<button type="button">P07</button>
			<button type="button">P08</button>
			<button type="button">P09</button>
			<button type="button">P10</button><br />
			<button type="button">P11</button>
			<button type="button">P12</button>
			<button type="button">P13</button>
			<button type="button">P14</button>
			<button type="button">P15</button>
			<button type="button">P16</button>
			<button type="button">P17</button>
			<button type="button">P18</button>
			<button type="button">P19</button>
			<button type="button">P20</button><br />
			<button type="button">P21</button>
			<button type="button">P22</button>
			<button type="button">P23</button>
			<button type="button">P24</button>
			<button type="button">P25</button>
			<button type="button">P26</button>
			<button type="button">P27</button>
			<button type="button">P28</button>
			<button type="button">P29</button>
			<button type="button">P30</button><br />
			<button type="button">P31</button>
			<button type="button">P32</button>
			<button type="button">P33</button>
			<button type="button">P34</button>
			<button type="button">P35</button>
			<button type="button">P36</button>
			<button type="button">P37</button>
			<button type="button">P38</button>
			<button type="button">P39</button>
			<button type="button">P40</button><br />
		</form>
		<script>


	//***********************************************************************************************
	// 変数設定
	//***********************************************************************************************
			let camera = {};
			let controls = {};
			let effect = {};
			let light = {};
			let mesh = {};
			let renderer = {};
			let scene = {};
			let canvasSizeW = Number( window.getComputedStyle( document.getElementById( 'webgl' ) ).width.replace( /[^0-9]/g, '' ) );
			let canvasSizeH = Number( window.getComputedStyle( document.getElementById( 'webgl' ) ).width.replace( /[^0-9]/g, '' ) ) * 540 / 960;
			// ステレオ表示に関する変数
			let stereoSwitch = 0;
			let radius = 4.5;
			let phiRadian = 90 * Math.PI / 180;
			let thetaRadian = 90 * Math.PI / 180;
			let vector3 = new THREE.Vector3();
			let vector11 = {};
			let vector12 = {};
			let vector13 = {};
			let vector14 = {};
			let pupillaryDistance1 = 0;
			let pupillaryDistance2 = 0.032;
			let isDragging = false;
			let isTouching = false;
			let baseX = 0;
			let baseY = 0;
			let baseRadius = 0;
			let basePhiRadian = 0;
			let baseThetaRadian = 0;
			let baseVector3 = new THREE.Vector3();
			let baseVector2 = new THREE.Vector2();
			let touchCount = 0;
			// WebM動画ファイルの保存に関する変数
			let isRecording = false;
			let mediaRecorder = {};
			// MMD 3Dモデルのモーションに関連する変数
			const ANIMATION_HELPER = new THREE.MMDAnimationHelper();
			const CLOCK = new THREE.Clock();
			let animationMixer = {};
			let motions = [];
			// モーションのインデックス、-1の時はモーションは適用されていないことを示す
			let motionIndex = -1;
			// ポーズのインデックス、-1の時はポーズは適用されていないことを示す
			let poseIndex = -1;
			// 読み込むMMD 3Dモデルのファイル(PMXファイル)をオブジェクトで管理する
			const PMX_FILE = { name: 'ニコニ立体ちゃん', file: '../assets/models/Sakuramiko_Sports.pmx', emissive: 0.3, multiply: 0.0739, physics: true, receiveShadow: true, thickness: 0.001 };
			// 読み込むモーションファイル(VMDファイル)をオブジェクトで管理する
			const VMD_FILES = [
				{ name: 'マフティダンス', file: '../assets/motions/mafty_dance.vmd' },
				{ name: '2分ループステップ5', file: './Alicia/MMD Motion/2分ループステップ5.vmd' },
				{ name: '2分ループステップ7', file: './Alicia/MMD Motion/2分ループステップ7.vmd' },
				{ name: '2分ループステップ8', file: './Alicia/MMD Motion/2分ループステップ8.vmd' },
				{ name: '2分ループステップ10', file: './Alicia/MMD Motion/2分ループステップ10.vmd' },
				{ name: '2分ループステップ17', file: './Alicia/MMD Motion/2分ループステップ17.vmd' },
				{ name: '2分ループステップ19', file: './Alicia/MMD Motion/2分ループステップ19.vmd' },
				{ name: '2分ループステップ20', file: './Alicia/MMD Motion/2分ループステップ20.vmd' },
				{ name: '2分ループステップ21', file: './Alicia/MMD Motion/2分ループステップ21.vmd' },
				{ name: '2分ループステップ22', file: './Alicia/MMD Motion/2分ループステップ22.vmd' },
				{ name: '2分ループステップ23', file: './Alicia/MMD Motion/2分ループステップ23.vmd' },
				{ name: '2分ループステップ28', file: './Alicia/MMD Motion/2分ループステップ28.vmd' },
				{ name: '2分ループステップ29', file: './Alicia/MMD Motion/2分ループステップ29.vmd' },
				{ name: '2分ループステップ31', file: './Alicia/MMD Motion/2分ループステップ31.vmd' },
				{ name: '2分ループステップ36', file: './Alicia/MMD Motion/2分ループステップ36.vmd' },
				{ name: '2分ループステップ37', file: './Alicia/MMD Motion/2分ループステップ37.vmd' }
			];
			// 読み込むポーズファイル(VPDファイル)をオブジェクトで管理する
			const VPD_FILES = [
				{ name: 'サロン・デ・サン-1896', file: './サロン・デ・サン-1896.vpd' },
				{ name: 'サロン・デ・サン-1897', file: './サロン・デ・サン-1897.vpd' },
				{ name: '四季-1896_春', file: './四季-1896_春.vpd' },
				{ name: '四季-1896_夏', file: './四季-1896_夏.vpd' },
				{ name: '四季-1896_秋', file: './四季-1896_秋.vpd' },
				{ name: '四季-1896_冬', file: './四季-1896_冬.vpd' },
				{ name: '四季-1897_1.2.3月', file: './四季-1897_1.2.3月.vpd' },
				{ name: '四季-1897_4.5.6月', file: './四季-1897_4.5.6月.vpd' },
				{ name: '四季-1897_7.8.9月', file: './四季-1897_7.8.9月.vpd' },
				{ name: '四季-1897_10.11.12月', file: './四季-1897_10.11.12月.vpd' },
				{ name: '夢想', file: './夢想.vpd' },
				{ name: '花_アイリス', file: './花_アイリス.vpd' },
				{ name: '花_カーネーション', file: './花_カーネーション.vpd' },
				{ name: '花_リリー', file: './花_リリー.vpd' },
				{ name: '花_ローズ', file: './花_ローズ.vpd' },
				{ name: '芸術_音楽', file: './芸術_音楽.vpd' },
				{ name: '芸術_絵画', file: './芸術_絵画.vpd' },
				{ name: '芸術_詩歌', file: './芸術_詩歌.vpd' },
				{ name: '芸術_舞踏', file: './芸術_舞踏.vpd' },
				{ name: 'シャンパン・ホワイト・スター', file: './シャンパン・ホワイト・スター.vpd' },
				{ name: '桜草', file: './桜草.vpd' },
				{ name: '羽根', file: './羽根.vpd' },
				{ name: '時_朝の目覚め', file: './時_朝の目覚め.vpd' },
				{ name: '時_昼の輝き', file: './時_昼の輝き.vpd' },
				{ name: '時_夕べの夢想', file: './時_夕べの夢想.vpd' },
				{ name: '時_夜の安らぎ', file: './時_夜の安らぎ.vpd' },
				{ name: '宝石_アメジスト', file: './宝石_アメジスト.vpd' },
				{ name: '宝石_エメラルド', file: './宝石_エメラルド.vpd' },
				{ name: '宝石_トパーズ', file: './宝石_トパーズ.vpd' },
				{ name: '宝石_ルビー', file: './宝石_ルビー.vpd' },
				{ name: '四季-1900_春', file: './四季-1900_春.vpd' },
				{ name: '四季-1900_夏', file: './四季-1900_夏.vpd' },
				{ name: '四季-1900_秋', file: './四季-1900_秋.vpd' },
				{ name: '四季-1900_冬', file: './四季-1900_冬.vpd' },
				{ name: '万国博覧会オーストリア館ポスター', file: './万国博覧会オーストリア館ポスター.vpd' },
				{ name: '星_月', file: './星_月.vpd' },
				{ name: '星_宵の明星', file: './星_宵の明星.vpd' },
				{ name: '星_北極星', file: './星_北極星.vpd' },
				{ name: '星_明けの明星', file: './星_明けの明星.vpd' },
				{ name: 'ヒヤシンス姫', file: './ヒヤシンス姫.vpd' }
			];
	//***********************************************************************************************
	// メインプログラム
	//***********************************************************************************************
			// DOMの解析が終わったらメインプログラムを実行
			document.addEventListener( 'DOMContentLoaded', function () {
				// Ammo の 「Ammo.btDefaultCollisionConfiguration is not a function」 のエラー回避
				Ammo().then( function ( AmmoLib ) {
					Ammo = AmmoLib;
					// (1) シーンの準備
					prepareScene();
					// (2) MMD 3Dモデルをロードし、シーンに追加
					loadMMD();
					// (3) レンダリング (レンダリングループ)
					sceneRender();

				} );
			}, false );
		//-----------------------------------------------------------------------------------------------
		// (1)シーンの準備
		//-----------------------------------------------------------------------------------------------
			function prepareScene() {
				renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( canvasSizeW, canvasSizeH );
				//renderer.setClearColor( 0xffffff, 1.0 );
				renderer.shadowMap.enabled = true;
				renderer.shadowMap.type = THREE.PCFSoftShadowMap;
				document.getElementById( 'webgl' ).appendChild( renderer.domElement );
				effect = new THREE.OutlineEffect( renderer );
				scene = new THREE.Scene();
				scene.add( new THREE.AmbientLight( 0xffffff, 0.6 ) );
				light = new THREE.DirectionalLight( 0xffe2b9, 0.4 );
				light.castShadow = true;
				light.position.copy( new THREE.Vector3( 2, 4.7, 2 ) );
				light.shadow.mapSize.copy( new THREE.Vector2 ( Math.pow( 2, 10 ), Math.pow( 2, 10 ) ) );
				light.shadow.focus = 1;
				light.shadow.normalBias = 0.02;
				light.shadow.bias = -0.0005;
				light.shadow.camera.left = -5;
				light.shadow.camera.right = 5;
				light.shadow.camera.top = 5;
				light.shadow.camera.bottom = -5;
				light.shadow.camera.near = 0.1;
				light.shadow.camera.far = 20;
				scene.add( light );
				scene.add( light.target );
				camera = new THREE.PerspectiveCamera( 22.9, canvasSizeW / canvasSizeH, 0.1, 20 );
				const GROUND_MESH = new THREE.Mesh( new THREE.PlaneGeometry( 10, 10, 1, 1 ), new THREE.ShadowMaterial( { opacity: 0.25 } ) );
				GROUND_MESH.geometry.rotateX( -90 * Math.PI / 180 );
				GROUND_MESH.receiveShadow = true;
				//scene.add( GROUND_MESH );
				//scene.add( new THREE.GridHelper( 8, 20, 0x000000, 0x999999 ) );
				//scene.add( new THREE.AxesHelper( 4 ) );
			}
		//-----------------------------------------------------------------------------------------------
		// (2) MMD 3Dモデルをロードし、シーンに追加
		//-----------------------------------------------------------------------------------------------
			function loadMMD () {
				const LOADER_1 = new THREE.MMDLoader();
				const LOADER_2 = new THREE.MMDLoader();
				LOADER_1.load (
					// オブジェクトで管理しているMMD 3Dモデルのファイル(PMXファイル)のファイル名プロパティーを使用
					PMX_FILE.file,
					function ( mmd ) {
						mesh = mmd;
						// オブジェクトで管理しているMMD 3Dモデルのファイル(PMXファイル)の放出度および輪郭線の太さのプロパティーを使用
						for ( let i = 0; i < mesh.material.length; i ++ ) {
							mesh.material[ i ].emissive.multiplyScalar( PMX_FILE.emissive );
							mesh.material[ i ].userData.outlineParameters.thickness = PMX_FILE.thickness;
						}
						// オブジェクトで管理しているMMD 3Dモデルのファイル(PMXファイル)のセルフシャドウ(receiveShadow)のプロパティーを使用
						mesh.castShadow = true;
						if ( PMX_FILE.receiveShadow ) {
							mesh.receiveShadow = true;
						} else {
							mesh.receiveShadow = false;
						}
						// オブジェクトで管理しているMMD 3Dモデルのファイル(PMXファイル)の倍率のプロパティーを使用
						mesh.scale.copy( new THREE.Vector3( 1, 1, 1 ).multiplyScalar( PMX_FILE.multiply ) );
						const BOUNDING_BOX = new THREE.Box3().setFromObject( mesh );
						vector3.setY( 0.5 * BOUNDING_BOX.max.y );
						light.target.position.copy( new THREE.Vector3( 0, 0.5 * BOUNDING_BOX.max.y, 0 ) );
						// モーションファイル(VMDファイル)を読み込んで、AnimationClip(配列で管理する)を作成
						for ( let i = 0; i < VMD_FILES.length; i ++ ) {
							LOADER_2.loadAnimation( VMD_FILES[ i ].file, mesh, function ( motion ) {
								// モーションファイルはAnimationClipとして読み込まれる、配列に保存
								motions[ i ] = motion;
								// AnimationClipのnameプロパティーの設定
								motions[ i ].name = VMD_FILES[ i ].name;
							} );
						}
						// オブジェクトで管理しているMMD 3Dモデルのファイル(PMXファイル)の物理演算のプロパティーを使用 物理演算あり(true) / 物理演算なし(false) 
						if ( PMX_FILE.physics ) {
							// (Constructor) MMDAnimationHelper( params : Object )
							// (Method) .add ( object : Object3D, params : Object ) : MMDAnimationHelper
							ANIMATION_HELPER.add( mesh, { animation: motions, physics: true } );
						} else {
							ANIMATION_HELPER.add( mesh, { animation: motions, physics: false } );
						}
						// 再生、停止、一時停止を制御するための AnimationMixer を取得
						// (Property) .objects : WeakMap
						animationMixer = ANIMATION_HELPER.objects.get( mesh ).mixer;
						// AnimationHelperにより開始したモーションを停止する
						// (Method) .stopAllAction () : AnimationMixer
						animationMixer.stopAllAction();
						scene.add( mesh );
					}
				);
			}
		//-----------------------------------------------------------------------------------------------
		// (3)レンダリング (レンダリングループ)
		//-----------------------------------------------------------------------------------------------
			function sceneRender() {
				window.requestAnimationFrame( sceneRender );
				// ポーズの場合、MMDAnimationHelperのupdateは行わない。
				// モーションの場合は、時間を進めて、オブジェクトのアニメーションを更新する
				if ( motionIndex !== -1 ) {
					// (Method) .update ( delta : Number ) : MMDAnimationHelper
					ANIMATION_HELPER.update( CLOCK.getDelta() );
				}
				cameraPosition();
				if ( stereoSwitch === 0 ) {
					camera.position.copy( vector11 );
					camera.lookAt( vector12 );
					effect.render( scene, camera );
				} else if ( stereoSwitch === 1 ) {
					camera.position.copy( vector11 );
					camera.lookAt( vector12 );
					renderer.setScissor( 0, 0, canvasSizeW / 2, canvasSizeH );
					renderer.setViewport( -1 * canvasSizeW / 4, 0, canvasSizeW, canvasSizeH );
					effect.render( scene, camera );
					camera.position.copy( vector13 );
					camera.lookAt( vector14 );
					renderer.setScissor( canvasSizeW / 2, 0, canvasSizeW / 2, canvasSizeH );
					renderer.setViewport( canvasSizeW / 4, 0, canvasSizeW, canvasSizeH );
					effect.render( scene, camera );
				}

			}
	//***********************************************************************************************
	// イベント
	//***********************************************************************************************
		//-----------------------------------------------------------------------------------------------
		// ブラウザー（ウィンドウ）のサイズ変更時の処理
		//-----------------------------------------------------------------------------------------------
			window.addEventListener( 'resize', function () {
				// setScissorとsetViewportで使用する変数（canvasSizeW、canvasSizeH）の値を更新
				canvasSizeW = Number( window.getComputedStyle( document.getElementById( 'webgl' ) ).width.replace( /[^0-9]/g, '' ) );
				canvasSizeH = Number( window.getComputedStyle( document.getElementById( 'webgl' ) ).width.replace( /[^0-9]/g, '' ) ) * 540 / 960;
				effect.setSize( canvasSizeW, canvasSizeH );
			}, false );
		//-----------------------------------------------------------------------------------------------
		// モーションの開始/一時停止ボタン
		//-----------------------------------------------------------------------------------------------
			for ( let i = 0; i < 16; i ++ ) {
				document.form2.elements[ i ].addEventListener( 'click', function () {
					 // モーションの開始
					if ( motionIndex === -1 ) {
						// モーションを停止する
						//animationMixer.stopAllAction();
						// (Method) .play () : AnimationAction
						animationMixer.clipAction( motions[ i ] ).play();
						// (Method) .setLoop ( loopMode : Number, repetitions : Number ) : AnimationAction
						animationMixer.clipAction( motions[ i ] ).setLoop( THREE.LoopOnce );
						motionIndex = i;
						poseIndex = -1;
					} else if ( motionIndex === i && animationMixer.clipAction( motions[ i ] ).paused === false ) {
						// モーションの一時停止
						// (Property) .paused : Boolean
						animationMixer.clipAction( motions[ i ] ).paused = true;
					} else if ( motionIndex === i && animationMixer.clipAction( motions[ i ] ).paused === true ) {
						// モーションの一時停止から再開
						animationMixer.clipAction( motions[ i ] ).paused = false;
					} else {
						// モーションを停止して、他のモーションの開始
						// (Method) .stop () : AnimationAction
						animationMixer.clipAction( motions[ motionIndex ] ).stop();
						animationMixer.clipAction( motions[ i ] ).play();
						animationMixer.clipAction( motions[ i ] ).setLoop( THREE.LoopOnce );
						motionIndex = i;
						poseIndex = -1;
					}
				}, false );
			}
		//-----------------------------------------------------------------------------------------------
		// ポーズの開始/一時停止ボタン
		//-----------------------------------------------------------------------------------------------
			for ( let i = 0; i < 40; i ++ ) {
				document.form3.elements[ i ].addEventListener( 'click', function () {
					// VPDファイルを読込ためのMMDLoader
					const LOADER_1 = new THREE.MMDLoader();
					// ポーズ用のMMDAnimationHelperオブジェクト
					const ANIMATION_HELPER_1 = new THREE.MMDAnimationHelper();
					if ( poseIndex === -1 ) {
						// モーションを停止する
						animationMixer.stopAllAction();
						// ポーズの開始
						// VPDファイルの読込
						// loadVPD( url : String, isUnicode : Boolean,	onLoad : Function, onProgress : Function, onError : Function ) : Object
						LOADER_1.loadVPD( VPD_FILES[ i ].file, false, function ( pose ) {
							// (Method) .pose ( mesh : SkinnedMesh, vpd : Object, params : Object ) : MMDAnimationHelper
							ANIMATION_HELPER_1.pose( mesh, pose, { resetPose: true, ik: true, grant: true } );
						} );
						motionIndex = -1;
						poseIndex = i;
					} else if ( poseIndex === i ) {
						// ポーズの停止(リセット)
						mesh.pose();
						poseIndex = -1;
					} else {
						// ポーズを停止して、他のポーズの開始
						LOADER_1.loadVPD( VPD_FILES[ i ].file, false, function ( pose ) {
							ANIMATION_HELPER_1.pose( mesh, pose, { resetPose: true } );
						} );
						motionIndex = -1;
						poseIndex = i;
					}
				}, false );
			}
		//-----------------------------------------------------------------------------------------------
		// ボタンがクリックされたらステレオ表示/ノーマル表示を切り替える
		//-----------------------------------------------------------------------------------------------
			document.form1.button1.onclick = function() {
				if ( stereoSwitch === 0 ) {
					pupillaryDistance1 = pupillaryDistance2;
					camera.fov = 22.9;
					camera.updateProjectionMatrix();
					renderer.setScissorTest( true );
					stereoSwitch = 1;
				} else {
					pupillaryDistance1 = 0;
					camera.fov = 22.9;
					camera.updateProjectionMatrix();
					renderer.setScissor( 0, 0, canvasSizeW, canvasSizeH );
					renderer.setViewport( 0, 0, canvasSizeW, canvasSizeH );
					renderer.setScissorTest( false );
					stereoSwitch = 0;
				}
			};
		//-----------------------------------------------------------------------------------------------
		// 画面上でのドラッグの開始/終了
		//-----------------------------------------------------------------------------------------------
			document.getElementById( 'webgl' ).addEventListener( 'pointerdown', function ( event ) {
				event.preventDefault();
				isDragging = true;
				baseX = event.clientX;
				baseY = event.clientY;
				basePhiRadian = phiRadian;
				baseThetaRadian = thetaRadian;
				baseVector3 = vector3.clone();
				if ( event.buttons === 4 ) {
					radius = 4.5;
				}
			}, false );
			document.getElementById( 'webgl' ).addEventListener( 'pointerup', function () {
				if ( isDragging === true ) {
					isDragging = false;
				}
			}, false );
			document.getElementById( 'webgl' ).addEventListener( 'pointerout', function () {
				if ( isDragging === true ) {
					isDragging = false;
				}
			}, false );
		//-----------------------------------------------------------------------------------------------
		// 画面上でのドラッグ操作
		//-----------------------------------------------------------------------------------------------
			document.getElementById( 'webgl' ).addEventListener( 'pointermove' , function ( event ) {
				event.preventDefault();
				if ( isDragging === true ) {
					if ( event.buttons === 1 ){
						phiRadian = basePhiRadian + ( 2 * Math.PI / this.clientWidth ) * ( event.clientX - baseX );
						if ( thetaRadian >= 5 * Math.PI / 180 && thetaRadian <= 175 * Math.PI / 180 ) {
							thetaRadian = baseThetaRadian - ( Math.PI / this.clientHeight ) * ( event.clientY - baseY );
						} else if ( thetaRadian < 5 * Math.PI / 180 && event.movementY < 0 ) {
							thetaRadian = 5 * Math.PI / 180;
							baseThetaRadian = 5 * Math.PI / 180;
							baseY = event.clientY;
						} else if ( thetaRadian > 175 * Math.PI / 180 && event.movementY > 0 ) {
							thetaRadian = 175 * Math.PI / 180;
							baseThetaRadian = 175 * Math.PI / 180;
							baseY = event.clientY;
						}
					} else if ( event.buttons === 2 ) {
						vector3.x = baseVector3.x - radius * ( 0.709 / this.clientWidth ) * Math.sin( phiRadian ) * ( event.clientX - baseX );
						vector3.y = baseVector3.y + radius * ( 0.709 / this.clientWidth ) * ( event.clientY - baseY );
						vector3.z = baseVector3.z + radius * ( 0.709 / this.clientWidth ) * Math.cos( phiRadian ) * ( event.clientX - baseX );
					}
				}
			}, false );
		//-----------------------------------------------------------------------------------------------
		// 右クリックを離した時にメニューを表示させない
		//-----------------------------------------------------------------------------------------------
			document.getElementById( 'webgl' ).addEventListener( 'contextmenu', function ( event ) {
				event.preventDefault();
			}, false );
		//-----------------------------------------------------------------------------------------------
		// 画面上でのマウスホイールの操作
		//-----------------------------------------------------------------------------------------------
			document.getElementById( 'webgl' ).addEventListener( 'wheel', function ( event ) {
				event.preventDefault();
				radius += 0.001 * event.deltaY;
			}, false );
		//-----------------------------------------------------------------------------------------------
		// 画面上でのタッチ操作の開始/終了
		//-----------------------------------------------------------------------------------------------
			document.getElementById( 'webgl' ).addEventListener( 'touchstart', function ( event ) {
				event.preventDefault();
				if ( event.touches.length === 1 ) {
					if ( touchCount === 0 ) {
						touchCount ++;
						setTimeout( function () {
							touchCount = 0;
						}, 400 );
					} else {
						radius = 4.5;
						touchCount = 0;
					}
				} else if ( event.touches.length > 1 ) {
					isDragging = false;
					isTouching = true;
					baseVector2.x = event.touches[ 1 ].pageX - event.touches[ 0 ].pageX;
					baseVector2.y = event.touches[ 1 ].pageY - event.touches[ 0 ].pageY;
					baseX = event.touches[ 0 ].pageX;
					baseY = event.touches[ 0 ].pageY;
					baseRadius = radius;
					baseVector3 = vector3.clone();
				}
			}, false);
			document.getElementById( 'webgl' ).addEventListener( 'touchend', function ( event ) {
				event.preventDefault();
				isTouching = false;
			}, false);
		//-----------------------------------------------------------------------------------------------
		// 画面上でのタッチ操作、ピンチイン、ピンチアウトの操作
		//-----------------------------------------------------------------------------------------------
			document.getElementById( 'webgl' ).addEventListener( 'touchmove', function ( event ) {
				event.preventDefault();
				if ( isTouching === true ) {
					const x1 = event.touches[ 0 ].pageX;
					const y1 = event.touches[ 0 ].pageY;
					const x2 = event.touches[ 1 ].pageX;
					const y2 = event.touches[ 1 ].pageY;
					const vector2 = new THREE.Vector2( x2 - x1, y2 - y1 );
					const deltaDistance = vector2.length() - baseVector2.length();
					radius = baseRadius - 0.01 * deltaDistance;
					vector3.x = baseVector3.x - radius * ( 0.709 / this.clientWidth ) * Math.sin( phiRadian ) * ( x1 - baseX );
					vector3.y = baseVector3.y + radius * ( 0.709 / this.clientWidth ) * ( y1 - baseY );
					vector3.z = baseVector3.z + radius * ( 0.709 / this.clientWidth ) * Math.cos( phiRadian ) * ( x1 - baseX );
				}
			}, false );
		//-----------------------------------------------------------------------------------------------
		// PNG画像保存ボタン
		//-----------------------------------------------------------------------------------------------
			document.form1.button2.addEventListener( 'click', function () {
				renderer.domElement.getContext( 'webgl2', { antialias: true, preserveDrawingBuffer: true } );
				// ステレオ表示に対応
				if ( stereoSwitch === 0 ) {
					camera.position.copy( vector11 );
					camera.lookAt( vector12 );
					effect.render( scene, camera );
				} else if ( stereoSwitch === 1 ) {
					camera.position.copy( vector11 );
					camera.lookAt( vector12 );
					renderer.setScissor( 0, 0, canvasSizeW / 2, canvasSizeH );
					renderer.setViewport( -1 * canvasSizeW / 4, 0, canvasSizeW, canvasSizeH );
					effect.render( scene, camera );
					camera.position.copy( vector13 );
					camera.lookAt( vector14 );
					renderer.setScissor( canvasSizeW / 2, 0, canvasSizeW / 2, canvasSizeH );
					renderer.setViewport( canvasSizeW / 4, 0, canvasSizeW, canvasSizeH );
					effect.render( scene, camera );
				}
				renderer.domElement.toBlob( function ( blob ) {
					const BLOB_URL = URL.createObjectURL( blob );
					const A = document.createElement( 'a' );
					A.download = 'pngfile.png';
					A.href = BLOB_URL;
					A.click();
					URL.revokeObjectURL( BLOB_URL );
				}, 'image/png' );
				renderer.domElement.getContext( 'webgl2', { antialias: true, preserveDrawingBuffer: false } );
			}, false );
		//-----------------------------------------------------------------------------------------------
		// イベント WebM動画保存ボタン
		//-----------------------------------------------------------------------------------------------
			document.form1.button3.addEventListener( 'click', function () {
				if ( isRecording === false ) {
					document.form1.button3.innerHTML = '録画停止';
					isRecording = true;
					const MEDIA_STREAM = renderer.domElement.captureStream( 24 );
					mediaRecorder = new MediaRecorder( MEDIA_STREAM, { mimeType: 'video/webm; codecs=vp8' } );
					mediaRecorder.start();
					mediaRecorder.ondataavailable = function ( event ) {
						const BLOB_URL = URL.createObjectURL( new Blob( [ event.data ], { type: event.data.type } ) );
						const A = document.createElement( 'a' );
						A.download = 'webmfile.webm';
						A.href = BLOB_URL;
						A.click();
						URL.revokeObjectURL( BLOB_URL );
					};
					// VPDファイルを読込ためのMMDLoader
					const LOADER_1 = new THREE.MMDLoader();
					// ポーズ用のMMDAnimationHelperオブジェクト
					const ANIMATION_HELPER_1 = new THREE.MMDAnimationHelper();



						// モーションを停止する
						//animationMixer.stopAllAction();
						LOADER_1.loadVPD( VPD_FILES[1].file, false, function ( pose ) {
							// (Method) .pose ( mesh : SkinnedMesh, vpd : Object, params : Object ) : MMDAnimationHelper
							ANIMATION_HELPER_1.pose( mesh, pose, { resetPose: true, ik: true, grant: true } );
						} );
						//motionIndex = -1;
						//poseIndex = 0;
						// モーションを停止する
						//animationMixer.stopAllAction();
						// (Method) .play () : AnimationAction
						animationMixer.clipAction( motions[0] ).play();
						// (Method) .setLoop ( loopMode : Number, repetitions : Number ) : AnimationAction
						animationMixer.clipAction( motions[0] ).setLoop( THREE.LoopOnce );
						motionIndex = 0;
						poseIndex = 0;

				} else if ( isRecording === true ) {
					document.form1.button3.innerHTML = 'WebM動画録画';
					isRecording = false;
					mediaRecorder.stop();
				}
			}, false );
	//***********************************************************************************************
	// ライブラリー
	//***********************************************************************************************
		//-----------------------------------------------------------------------------------------------
		// カメラの位置、視点(LookAt)の場所計算
		//-----------------------------------------------------------------------------------------------
			function cameraPosition() {
				vector12 = new THREE.Vector3( Math.cos( phiRadian + Math.PI / 2 ), 0, Math.sin( phiRadian + Math.PI / 2 ) ).multiplyScalar( pupillaryDistance1 );
				vector12.add( vector3 );
				vector14 = new THREE.Vector3( Math.cos( phiRadian - Math.PI / 2 ), 0, Math.sin( phiRadian - Math.PI / 2 ) ).multiplyScalar( pupillaryDistance1 );
				vector14.add( vector3 );
				vector11 = vector12.clone();
				vector11.add( new THREE.Vector3( Math.sin( thetaRadian ) * Math.cos( phiRadian ), Math.cos( thetaRadian ), Math.sin( thetaRadian ) * Math.sin( phiRadian ) ).multiplyScalar( radius ) );
				vector13 = vector14.clone();
				vector13.add( new THREE.Vector3( Math.sin( thetaRadian ) * Math.cos( phiRadian ), Math.cos( thetaRadian ), Math.sin( thetaRadian ) * Math.sin( phiRadian ) ).multiplyScalar( radius ) );
			}
		</script>
	</body>
</html>
