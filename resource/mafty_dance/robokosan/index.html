<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta property="og:url" content="https://holonovels.github.io/resource/mafty_dance/robokosan/">
<meta property="og:title" content="ガンダム風ロボ子さん - マフティーダンス">
<meta property="og:description" content="MMDモデルを使ったWebGL(three.js)による素材作り、ガンダム風ロボ子さんで、マフティーダンス">
<meta property="og:type" content="website">
<meta property="og:locale" content="ja_JP">
<meta property="og:site_name" content="ホロライブ非公式ノベルズ">
<meta property="og:image" content="https://holonovels.github.io/resource/mafty_dance/robokosan/ogp_tw1200x630.jpg">
<meta property="og:image:secure_url" content="https://holonovels.github.io/resource/mafty_dance/robokosan/ogp_tw1200x630.jpg">
<meta property="og:image:alt" content="ガンダム風ロボ子さん - マフティーダンス" />
<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="630">
<meta property="og:image:type" content="image/jpeg">
<meta name="twitter:title" content="ガンダム風ロボ子さん - マフティーダンス">
<meta name="twitter:description" content="MMDモデルを使ったWebGL(three.js)による素材作り、ガンダム風ロボ子さんで、マフティーダンス">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://holonovels.github.io/resource/mafty_dance/robokosan/ogp_tw1200x630.jpg">
<link rel="canonical" href="https://holonovels.github.io/resource/mafty_dance/robokosan/">
<script src="config.js"></script>
<link rel="stylesheet" type="text/css" href="style.css">
<title>ガンダム風ロボ子さん - マフティーダンス</title>
</head>

<body>
<!-- MMDが描画されるHTML要素(widthの値から自動的に16:9で計算) -->
<div id="webgl" style="width: 1200px;"></div>

<h3>コントロール</h3>
<form name="control">
<!-- モーションの開始/一時停止ボタン -->
<button type="button" name="button_motion">マフティーダンス</button>
<!-- WebM動画保存ボタン -->
<button type="button" name="button_webm">WebM動画保存</button>
<!-- 一時停止ボタン -->
<button type="button" name="button_pause">一時停止</button>
<!-- PNG画像保存ボタン -->
<button type="button" name="button_png">PNG画像保存</button>
</form>

<h3>表情</h3>
<form name="morph"></form>

<script>
//***********************************************************************************************
// 変数設定
//***********************************************************************************************
let camera = {};
let controls = {};
let effect = {};
let light = {};
let mesh = {};
let renderer = {};
let scene = {};
let canvasSizeW = Number( window.getComputedStyle( document.getElementById( 'webgl' ) ).width.replace( /[^0-9]/g, '' ) );
let canvasSizeH = Number( window.getComputedStyle( document.getElementById( 'webgl' ) ).width.replace( /[^0-9]/g, '' ) ) * 540 / 960;
// ステレオ表示に関する変数
let stereoSwitch = 0;
let radius = 4.2;// カメラ距離
let phiRadian = 90 * Math.PI / 180;
let thetaRadian = 90 * Math.PI / 180;
let vector3 = new THREE.Vector3();
let vector11 = {};
let vector12 = {};
let vector13 = {};
let vector14 = {};
let pupillaryDistance1 = 0;
let pupillaryDistance2 = 0.032;
let isDragging = false;
let isTouching = false;
let baseX = 0;
let baseY = 0;
let baseRadius = 0;
let basePhiRadian = 0;
let baseThetaRadian = 0;
let baseVector3 = new THREE.Vector3();
let baseVector2 = new THREE.Vector2();
let touchCount = 0;
// WebM動画ファイルの保存に関する変数
let isRecording = false;
let mediaRecorder = {};
// MMD 3Dモデルのモーションに関連する変数
const ANIMATION_HELPER = new THREE.MMDAnimationHelper();
const CLOCK = new THREE.Clock();
let animationMixer = {};
let motions = [];
// モーションのインデックス、-1の時はモーションは適用されていないことを示す
let motionIndex = -1;
// ポーズのインデックス、-1の時はポーズは適用されていないことを示す
//let poseIndex = -1;
// 読み込むMMD 3Dモデルのファイル(PMXファイル)をオブジェクトで管理する
const PMX_FILE = { name: 'ロボ子さん', file: '../../assets/models/robokosan/hoodie_normal_gundam.pmx', emissive: 0.3, multiply: 0.0739, physics: true, receiveShadow: true, thickness: 0.001 };
// 読み込むモーションファイル(VMDファイル)をオブジェクトで管理する
const VMD_FILE = { name: 'マフティーダンス', file: '../../assets/motions/mafty_dance.vmd' };
const filename = 'mafft_dance_robokosan';
let premorph = 0;

//***********************************************************************************************
// メインプログラム
//***********************************************************************************************
// DOMの解析が終わったらメインプログラムを実行
document.addEventListener( 'DOMContentLoaded', function () {
	// Ammo の 「Ammo.btDefaultCollisionConfiguration is not a function」 のエラー回避
	Ammo().then( function ( AmmoLib ) {
		Ammo = AmmoLib;
		// (1) シーンの準備
		prepareScene();
		// (2) MMD 3Dモデルをロードし、シーンに追加
		loadMMD();
		// (3) レンダリング (レンダリングループ)
		sceneRender();

	} );
}, false );

//-----------------------------------------------------------------------------------------------
// (1)シーンの準備
//-----------------------------------------------------------------------------------------------
function prepareScene() {
	renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );
	renderer.setPixelRatio( window.devicePixelRatio );
	renderer.setSize( canvasSizeW, canvasSizeH );
	//renderer.setClearColor( 0xffffff, 1.0 );
	renderer.shadowMap.enabled = true;
	renderer.shadowMap.type = THREE.PCFSoftShadowMap;
	document.getElementById( 'webgl' ).appendChild( renderer.domElement );
	effect = new THREE.OutlineEffect( renderer );
	scene = new THREE.Scene();
	scene.add( new THREE.AmbientLight( 0xffffff, 0.6 ) );
	light = new THREE.DirectionalLight( 0xffe2b9, 0.4 );
	light.castShadow = true;
	light.position.copy( new THREE.Vector3( 3, 2, 6 ) );
	light.shadow.mapSize.copy( new THREE.Vector2 ( Math.pow( 2, 10 ), Math.pow( 2, 10 ) ) );
	light.shadow.focus = 1;
	light.shadow.normalBias = 0.02;
	light.shadow.bias = -0.0005;
	light.shadow.camera.left = -5;
	light.shadow.camera.right = 5;
	light.shadow.camera.top = 5;
	light.shadow.camera.bottom = -5;
	light.shadow.camera.near = 0.1;
	light.shadow.camera.far = 20;
	scene.add( light );
	scene.add( light.target );
	camera = new THREE.PerspectiveCamera( 22.9, canvasSizeW / canvasSizeH, 0.1, 20 );
	const GROUND_MESH = new THREE.Mesh( new THREE.PlaneGeometry( 10, 10, 1, 1 ), new THREE.ShadowMaterial( { opacity: 0.25 } ) );
	GROUND_MESH.geometry.rotateX( -90 * Math.PI / 180 );
	GROUND_MESH.receiveShadow = true;
	//scene.add( GROUND_MESH );// 地面表示
	//scene.add( new THREE.GridHelper( 8, 20, 0x000000, 0x999999 ) );// グリッド表示
	//scene.add( new THREE.AxesHelper( 4 ) );// 角度表示
}

//-----------------------------------------------------------------------------------------------
// (2) MMD 3Dモデルをロードし、シーンに追加
//-----------------------------------------------------------------------------------------------
function loadMMD () {
	const LOADER_1 = new THREE.MMDLoader();
	const LOADER_2 = new THREE.MMDLoader();
	LOADER_1.load (
		// オブジェクトで管理しているMMD 3Dモデルのファイル(PMXファイル)のファイル名プロパティーを使用
		PMX_FILE.file,
		function ( mmd ) {
			mesh = mmd;
			// オブジェクトで管理しているMMD 3Dモデルのファイル(PMXファイル)の放出度および輪郭線の太さのプロパティーを使用
			for ( let i = 0; i < mesh.material.length; i ++ ) {
				mesh.material[ i ].emissive.multiplyScalar( PMX_FILE.emissive );
				mesh.material[ i ].userData.outlineParameters.thickness = PMX_FILE.thickness;
			}
			// オブジェクトで管理しているMMD 3Dモデルのファイル(PMXファイル)のセルフシャドウ(receiveShadow)のプロパティーを使用
			mesh.castShadow = true;
			if ( PMX_FILE.receiveShadow ) {
				mesh.receiveShadow = true;
			} else {
				mesh.receiveShadow = false;
			}
			// オブジェクトで管理しているMMD 3Dモデルのファイル(PMXファイル)の倍率のプロパティーを使用
			mesh.scale.copy( new THREE.Vector3( 1, 1, 1 ).multiplyScalar( PMX_FILE.multiply ) );
			const BOUNDING_BOX = new THREE.Box3().setFromObject( mesh );
			vector3.setY( 0.5 * BOUNDING_BOX.max.y );
			light.target.position.copy( new THREE.Vector3( 0, 0.5 * BOUNDING_BOX.max.y, 0 ) );
			// モーションファイル(VMDファイル)を読み込んで、AnimationClip(配列で管理する)を作成

			LOADER_2.loadAnimation( VMD_FILE.file, mesh, function ( motion ) {
				// モーションファイルはAnimationClipとして読み込まれる、配列に保存
				motions[0] = motion;
				// AnimationClipのnameプロパティーの設定
				motions[0].name = VMD_FILE.name;
			} );

			// オブジェクトで管理しているMMD 3Dモデルのファイル(PMXファイル)の物理演算のプロパティーを使用 物理演算あり(true) / 物理演算なし(false) 
			if ( PMX_FILE.physics ) {
				// (Constructor) MMDAnimationHelper( params : Object )
				// (Method) .add ( object : Object3D, params : Object ) : MMDAnimationHelper
				ANIMATION_HELPER.add( mesh, { animation: motions, physics: true } );
			} else {
				ANIMATION_HELPER.add( mesh, { animation: motions, physics: false } );
			}
			// 再生、停止、一時停止を制御するための AnimationMixer を取得
			// (Property) .objects : WeakMap
			animationMixer = ANIMATION_HELPER.objects.get( mesh ).mixer;
			// AnimationHelperにより開始したモーションを停止する
			// (Method) .stopAllAction () : AnimationMixer
			animationMixer.stopAllAction();
			scene.add( mesh );


			// morphTargetDictionary 内の KEY 数をカウント
			let count = 0;
			// innerHTMLはHTMLを都度解釈するため、タグが補完されてしまうので、タグが補完されないよう一度変数に入れ、最後にまとめてinnerHTMLに渡す
			let htmlSource = '';
			// テーブル要素の追加（開始タグ）
			// <table style="max-width: 960px; text-align: center; width: 100%;">
			// <tr>
			htmlSource += '<table>\u000A';
			htmlSource += '<tr>\u000A';
			// メッシュ内のMorph Target Dictionaryに登録されているMorph（表情）を取得、ボタンにする
			// morphTargetDictionaryのキーがMorph Target Name、値がmorphTargetInfluences配列のインデックス
			// (Property) .morphTargetDictionary : Object
			for ( const KEY in mesh.morphTargetDictionary ) {
				// ボタンを追加
				// <td style="max-width: 160px; width: 16.7%;"><button type="button" value="****" style="max-width: 128px; width: 80%;">****</button></td>
				htmlSource += '<td><button type=\u0022button\u0022 value=\u0022' + mesh.morphTargetDictionary[ KEY ] + '\u0022>' + KEY + ' ( ' + mesh.morphTargetDictionary[ KEY ] + ' )' + '</button></td>\u000A';

				// 6列ごとに改行
				if ( count % 6 === 5 ) {
					// </tr>
					htmlSource += '</tr>\u000A';
					// <tr>
					htmlSource += '<tr>\u000A';
				}
				// カウントを加算
				count ++;
			}


			// 最後の行も6列となるように空白セルで埋める
			if ( count % 6 !== 5 ) {
				for ( let i = 6 - count % 6; i < 6; i ++ ) {
					// <td style="max-width: 160px; width: 16.7%;"></td>
					htmlSource += '<td></td>\u000A';
				}
			}
			// テーブル要素の追加（終了タグ）
			// </tr>
			// </table>
			htmlSource += '</tr>\u000A';
			htmlSource += '</table>\u000A';
			// 最後にまとめてinnerHTMLに渡す
			document.morph.innerHTML = htmlSource;

			// 追加したボタンにイベントを登録
			for ( let i = 0; i < document.morph.elements.length; i ++ ) {
				document.morph.elements[ i ].onclick = async function() {
					// morphTargetInfluencesの値を指定することで、Morph（表情）をつける
					// (Property) .morphTargetInfluences : Array
					mesh.morphTargetInfluences[ premorph ] = 0;// 前回のMorph（表情）を戻す
					mesh.morphTargetInfluences[ Number( document.morph.elements[ i ].value ) ] = 1;
					premorph = document.morph.elements[ i ].value;// Morph（表情）を保存
				};
			}

			// ランダムまばたき開始
			blink(mesh);
		}
	);
}

//-----------------------------------------------------------------------------------------------
// (3)レンダリング (レンダリングループ)
//-----------------------------------------------------------------------------------------------
function sceneRender() {
	window.requestAnimationFrame( sceneRender );
	// ポーズの場合、MMDAnimationHelperのupdateは行わない。
	// モーションの場合は、時間を進めて、オブジェクトのアニメーションを更新する
	if ( motionIndex !== -1 ) {
		// (Method) .update ( delta : Number ) : MMDAnimationHelper
		ANIMATION_HELPER.update( CLOCK.getDelta() );
	}
	cameraPosition();
	camera.position.copy( vector11 );
	camera.lookAt( vector12 );
	effect.render( scene, camera );
}

//-----------------------------------------------------------------------------------------------
// ランダムまばたき
//-----------------------------------------------------------------------------------------------
async function blink(mesh) {
	mesh.morphTargetInfluences[0] = 1;// まばたき
	await sleep(0.05);
	mesh.morphTargetInfluences[0] = 0;
	setTimeout(blink, Math.floor(Math.random()*11000), mesh);
}

//***********************************************************************************************
// ライブラリー
//***********************************************************************************************

//-----------------------------------------------------------------------------------------------
// カメラの位置、視点(LookAt)の場所計算
//-----------------------------------------------------------------------------------------------
function cameraPosition() {
	vector12 = new THREE.Vector3( Math.cos( phiRadian + Math.PI / 2 ), 0, Math.sin( phiRadian + Math.PI / 2 ) ).multiplyScalar( pupillaryDistance1 );
	vector12.add( vector3 );
	vector14 = new THREE.Vector3( Math.cos( phiRadian - Math.PI / 2 ), 0, Math.sin( phiRadian - Math.PI / 2 ) ).multiplyScalar( pupillaryDistance1 );
	vector14.add( vector3 );
	vector11 = vector12.clone();
	vector11.add( new THREE.Vector3( Math.sin( thetaRadian ) * Math.cos( phiRadian ), Math.cos( thetaRadian ), Math.sin( thetaRadian ) * Math.sin( phiRadian ) ).multiplyScalar( radius ) );
	vector13 = vector14.clone();
	vector13.add( new THREE.Vector3( Math.sin( thetaRadian ) * Math.cos( phiRadian ), Math.cos( thetaRadian ), Math.sin( thetaRadian ) * Math.sin( phiRadian ) ).multiplyScalar( radius ) );
}

//***********************************************************************************************
// イベント
//***********************************************************************************************

//-----------------------------------------------------------------------------------------------
// ブラウザー（ウィンドウ）のサイズ変更時の処理
//-----------------------------------------------------------------------------------------------
window.addEventListener( 'resize', function () {
	// setScissorとsetViewportで使用する変数（canvasSizeW、canvasSizeH）の値を更新
	canvasSizeW = Number( window.getComputedStyle( document.getElementById( 'webgl' ) ).width.replace( /[^0-9]/g, '' ) );
	canvasSizeH = Number( window.getComputedStyle( document.getElementById( 'webgl' ) ).width.replace( /[^0-9]/g, '' ) ) * 540 / 960;
	effect.setSize( canvasSizeW, canvasSizeH );
}, false );

//-----------------------------------------------------------------------------------------------
// 一時停止ボタン
//-----------------------------------------------------------------------------------------------
document.control.button_pause.addEventListener( 'click', function () {
	 // モーションの開始
	if ( motionIndex === 0 && animationMixer.clipAction( motions[0] ).paused === false ) {
		// モーションの一時停止
		// (Property) .paused : Boolean
		animationMixer.clipAction( motions[0] ).paused = true;
	} else if ( motionIndex === 0 && animationMixer.clipAction( motions[0] ).paused === true ) {
		// モーションの一時停止から再開
		animationMixer.clipAction( motions[0] ).paused = false;
	}
}, false );

//-----------------------------------------------------------------------------------------------
// モーションの開始
//-----------------------------------------------------------------------------------------------
document.control.button_motion.addEventListener( 'click', function () {
	animationMixer.clipAction( motions[0] ).reset();
	animationMixer.clipAction( motions[0] ).play();
	animationMixer.clipAction( motions[0] ).setLoop( THREE.LoopOnce );
	motionIndex = 0;
}, false );

//-----------------------------------------------------------------------------------------------
// 画面上でのドラッグの開始/終了
//-----------------------------------------------------------------------------------------------
document.getElementById( 'webgl' ).addEventListener( 'pointerdown', function ( event ) {
	event.preventDefault();
	isDragging = true;
	baseX = event.clientX;
	baseY = event.clientY;
	basePhiRadian = phiRadian;
	baseThetaRadian = thetaRadian;
	baseVector3 = vector3.clone();
	if ( event.buttons === 4 ) {
		radius = 4.5;
	}
}, false );

document.getElementById( 'webgl' ).addEventListener( 'pointerup', function () {
	if ( isDragging === true ) {
		isDragging = false;
	}
}, false );

document.getElementById( 'webgl' ).addEventListener( 'pointerout', function () {
	if ( isDragging === true ) {
		isDragging = false;
	}
}, false );

//-----------------------------------------------------------------------------------------------
// 画面上でのドラッグ操作
//-----------------------------------------------------------------------------------------------
document.getElementById( 'webgl' ).addEventListener( 'pointermove' , function ( event ) {
	event.preventDefault();
	if ( isDragging === true ) {
		if ( event.buttons === 1 ){
			phiRadian = basePhiRadian + ( 2 * Math.PI / this.clientWidth ) * ( event.clientX - baseX );
			if ( thetaRadian >= 5 * Math.PI / 180 && thetaRadian <= 175 * Math.PI / 180 ) {
				thetaRadian = baseThetaRadian - ( Math.PI / this.clientHeight ) * ( event.clientY - baseY );
			} else if ( thetaRadian < 5 * Math.PI / 180 && event.movementY < 0 ) {
				thetaRadian = 5 * Math.PI / 180;
				baseThetaRadian = 5 * Math.PI / 180;
				baseY = event.clientY;
			} else if ( thetaRadian > 175 * Math.PI / 180 && event.movementY > 0 ) {
				thetaRadian = 175 * Math.PI / 180;
				baseThetaRadian = 175 * Math.PI / 180;
				baseY = event.clientY;
			}
		} else if ( event.buttons === 2 ) {
			vector3.x = baseVector3.x - radius * ( 0.709 / this.clientWidth ) * Math.sin( phiRadian ) * ( event.clientX - baseX );
			vector3.y = baseVector3.y + radius * ( 0.709 / this.clientWidth ) * ( event.clientY - baseY );
			vector3.z = baseVector3.z + radius * ( 0.709 / this.clientWidth ) * Math.cos( phiRadian ) * ( event.clientX - baseX );
		}
	}
}, false );

//-----------------------------------------------------------------------------------------------
// 右クリックを離した時にメニューを表示させない
//-----------------------------------------------------------------------------------------------
document.getElementById( 'webgl' ).addEventListener( 'contextmenu', function ( event ) {
	event.preventDefault();
}, false );

//-----------------------------------------------------------------------------------------------
// 画面上でのマウスホイールの操作
//-----------------------------------------------------------------------------------------------
document.getElementById( 'webgl' ).addEventListener( 'wheel', function ( event ) {
	event.preventDefault();
	radius += 0.001 * event.deltaY;
}, false );

//-----------------------------------------------------------------------------------------------
// 画面上でのタッチ操作の開始/終了
//-----------------------------------------------------------------------------------------------
document.getElementById( 'webgl' ).addEventListener( 'touchstart', function ( event ) {
	event.preventDefault();
	if ( event.touches.length === 1 ) {
		if ( touchCount === 0 ) {
			touchCount ++;
			setTimeout( function () {
				touchCount = 0;
			}, 400 );
		} else {
			radius = 4.5;
			touchCount = 0;
		}
	} else if ( event.touches.length > 1 ) {
		isDragging = false;
		isTouching = true;
		baseVector2.x = event.touches[ 1 ].pageX - event.touches[ 0 ].pageX;
		baseVector2.y = event.touches[ 1 ].pageY - event.touches[ 0 ].pageY;
		baseX = event.touches[ 0 ].pageX;
		baseY = event.touches[ 0 ].pageY;
		baseRadius = radius;
		baseVector3 = vector3.clone();
	}
}, false);
document.getElementById( 'webgl' ).addEventListener( 'touchend', function ( event ) {
	event.preventDefault();
	isTouching = false;
}, false);

//-----------------------------------------------------------------------------------------------
// 画面上でのタッチ操作、ピンチイン、ピンチアウトの操作
//-----------------------------------------------------------------------------------------------
document.getElementById( 'webgl' ).addEventListener( 'touchmove', function ( event ) {
	event.preventDefault();
	if ( isTouching === true ) {
		const x1 = event.touches[ 0 ].pageX;
		const y1 = event.touches[ 0 ].pageY;
		const x2 = event.touches[ 1 ].pageX;
		const y2 = event.touches[ 1 ].pageY;
		const vector2 = new THREE.Vector2( x2 - x1, y2 - y1 );
		const deltaDistance = vector2.length() - baseVector2.length();
		radius = baseRadius - 0.01 * deltaDistance;
		vector3.x = baseVector3.x - radius * ( 0.709 / this.clientWidth ) * Math.sin( phiRadian ) * ( x1 - baseX );
		vector3.y = baseVector3.y + radius * ( 0.709 / this.clientWidth ) * ( y1 - baseY );
		vector3.z = baseVector3.z + radius * ( 0.709 / this.clientWidth ) * Math.cos( phiRadian ) * ( x1 - baseX );
	}
}, false );

//-----------------------------------------------------------------------------------------------
// PNG画像保存ボタン
//-----------------------------------------------------------------------------------------------
document.control.button_png.addEventListener( 'click', function () {
	renderer.domElement.getContext( 'webgl2', { antialias: true, preserveDrawingBuffer: true } );
	camera.position.copy( vector11 );
	camera.lookAt( vector12 );
	effect.render( scene, camera );
	renderer.domElement.toBlob( function ( blob ) {
		const BLOB_URL = URL.createObjectURL( blob );
		const A = document.createElement( 'a' );
		A.download = filename+'.png';
		A.href = BLOB_URL;
		A.click();
		URL.revokeObjectURL( BLOB_URL );
	}, 'image/png' );
	renderer.domElement.getContext( 'webgl2', { antialias: true, preserveDrawingBuffer: false } );
}, false );

//-----------------------------------------------------------------------------------------------
// イベント WebM動画保存ボタン
//-----------------------------------------------------------------------------------------------
document.control.button_webm.addEventListener( 'click', function () {
	if ( isRecording === false ) {
		document.control.button_webm.innerHTML = '録画停止';
		isRecording = true;
		const MEDIA_STREAM = renderer.domElement.captureStream( 24 );
		mediaRecorder = new MediaRecorder( MEDIA_STREAM, { mimeType: 'video/webm; codecs=vp8' } );
		mediaRecorder.start();
		mediaRecorder.ondataavailable = function ( event ) {
			const BLOB_URL = URL.createObjectURL( new Blob( [ event.data ], { type: event.data.type } ) );
			const A = document.createElement( 'a' );
			A.download = filename+'.webm';
			A.href = BLOB_URL;
			A.click();
			URL.revokeObjectURL( BLOB_URL );
		};
		// VPDファイルを読込ためのMMDLoader
		const LOADER_1 = new THREE.MMDLoader();
		// ポーズ用のMMDAnimationHelperオブジェクト
		const ANIMATION_HELPER_1 = new THREE.MMDAnimationHelper();

		animationMixer.clipAction( motions[0] ).reset();
		animationMixer.clipAction( motions[0] ).play();
		animationMixer.clipAction( motions[0] ).setLoop( THREE.LoopOnce );
		motionIndex = 0;

	} else if ( isRecording === true ) {
		document.control.button_webm.innerHTML = 'WebM動画録画';
		isRecording = false;
		mediaRecorder.stop();

		animationMixer.clipAction( motions[0] ).stop();
	}
}, false );

//***********************************************************************************************
// ライブラリー
//***********************************************************************************************

//-----------------------------------------------------------------------------------------------
// 非同期処理
//-----------------------------------------------------------------------------------------------
function sleep( second ) {
	return new Promise( function ( resolve ) {
		setTimeout( function() {
			resolve();
		}, second * 1000 );
	} );
}

</script>
</body>
</html>
